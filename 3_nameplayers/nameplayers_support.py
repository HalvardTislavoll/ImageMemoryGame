#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0
#  in conjunction with Tcl version 8.6
#    Jan 05, 2024 09:16:48 AM CET  platform: Linux
#    Jan 05, 2024 10:33:22 AM CET  platform: Linux

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

import nameplayers

# Importing other required modules
try:
    from PIL import Image, ImageTk
    import random
except:
    # can't import essential modules
    sys.exit()

#   ========================================================
#     Create share module and import it into the script
#   ========================================================
import os
module_name = "shared"   # empty_module
# Create the empty module file
with open(f"{module_name}.py", "w") as file:
    pass  # This creates an empty file
# Check if the file exists before importing
if os.path.isfile(f"{module_name}.py"):
    import importlib.util
    spec = importlib.util.spec_from_file_location(module_name, f"{module_name}.py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
else:
    print(f"File '{module_name}.py' does not exist. Failed to import the module.")
sh=importlib   # sh is alias shared for short
#   ========================================================

_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = nameplayers.Toplevel1(_top1)
    nameplayers_startup()
    root.mainloop()

def nameplayers_startup():
    _top1.title("up to four players")
    sh.im_dict = {}   # a dict to hold all images from disc
    sh.rnd_im_dict={}   # a dict to hold all images in random orderinit_players_image_dict(sh.rnd_im_dict)
    # init a image dict for each player
    sh.player1_im={}
    sh.player2_im={}
    sh.player3_im={}
    sh.player4_im={}
    sh.player_lst=[sh.player1_im, sh.player2_im, sh.player3_im, sh.player4_im]
    sh.player_name={}
    sh.player=0
    sh.form_color_lst=['blue', 'yellow', 'red', 'green']
    random.shuffle(sh.form_color_lst)
    _w1.Label1.configure(background=sh.form_color_lst[0])
    _w1.Label2.configure(background=sh.form_color_lst[1])
    _w1.Label3.configure(background=sh.form_color_lst[2])
    _w1.Label4.configure(background=sh.form_color_lst[3])
    sh.style = ttk.Style()
    make_mystyle()
    sh.id_lst=['MyTButton1.TButton','MyTButton2.TButton','MyTButton3.TButton','MyTButton4.TButton']
    sh.button_lst=[_w1.TBtnPlayer1, _w1.TBtnPlayer2, _w1.TBtnPlayer3, _w1.TBtnPlayer4]    
    set_form_color(sh.player)
    set_button_color()
    init_canvas()
    init_path()
    img_number = 36   # set number of images to load
    # make a list of all image names by List Comprehension
    sh.im_lst=[f'{x}.png' for x in range(1,img_number+1)]
    ## print(im_lst)   # ['1.png', '2.png', '3.png', '4.png', '5.png', '6.png', '7.png', '8.png', '9.png', '10.png', '11.png', '12.png', '13.png', '14.png', '15.png', '16.png', '17.png', '18.png', '19.png', '20.png', '21.png', '22.png', '23.png', '24.png', '25.png', '26.png', '27.png', '28.png', '29.png', '30.png', '31.png', '32.png', '33.png', '34.png', '35.png', '36.png']
    init_image_dict()
    sh.rnd_im_dict = dict_randomization(sh.im_dict)
    init_players_image_dict(sh.rnd_im_dict)
    player_dict=sh.player_lst[sh.player]
    # set binding to entry/return key
    _w1.TEntry1.bind('<Return>', retur_entry1)
    _w1.TEntry2.bind('<Return>', retur_entry2)
    _w1.TEntry3.bind('<Return>', retur_entry3)
    _w1.TEntry4.bind('<Return>', retur_entry4)
    # Trace changes in the entry value
    _w1.player1var.trace_add("write", validate_input1)
    _w1.player2var.trace_add("write", validate_input2)
    _w1.player3var.trace_add("write", validate_input3)
    _w1.player4var.trace_add("write", validate_input4)
    # set widget fokus
    _w1.TEntry1.tk_focusNext().focus_set()
    _w1.TEntry1.config(takefocus=1)
    display_image(player_dict) # player 1 at init time
    
#   ===========disse to linjene setter fokus p√• Entry boxen=============================================
#     Init Section
#   ========================================================
       
def init_names():
    # sh.name_lst=[sh.player1_name, sh.player2_name, sh.player3_name, sh.player4_name]
    for name_dict in sh.name_lst:
        pass
        
def init_canvas():
    sh.can1 = _w1.Canvas1
    sh.can2 = _w1.Canvas2
    sh.can3 = _w1.Canvas3
    sh.can4 = _w1.Canvas4
    sh.can5 = _w1.Canvas5
    sh.can6 = _w1.Canvas6
    sh.can7 = _w1.Canvas7
    sh.can8 = _w1.Canvas8
    sh.can9 = _w1.Canvas9
    sh.canvas_lst = [sh.can1, sh.can2, sh.can3, sh.can4, sh.can5, sh.can6, sh.can7, sh.can8, sh.can9]

def init_path():
    # parent dir path
    sh.path_parent = os.getcwd()
    # photo dir path
    sh.path_photo = sh.path_parent+"/assets/lotto_graphics"

def init_image_dict():
    # make a dicts with all images
    sh._img=[]
    global _img
    for inx, im in enumerate(sh.im_lst):
        if inx < 36:
            # join path and filename to photo_location for a photo
            fn = im
            photo_location = os.path.join(sh.path_photo,fn)
            #loading the image 
            original = Image.open(photo_location)
            # Create a thumbnail
            thumbnail_size=(200,200)
            original.thumbnail(thumbnail_size)   # 600x600 -> 200x200
            sh._img.append(inx+1)
            sh._img[inx] = ImageTk.PhotoImage(original)
            # save origin        self.TLblLid.place(x=0, y=0, height=51, width=424)al to dict
            _img=f'{sh._img[inx]}'
            if not _img in sh.im_dict:
                sh.im_dict[_img] = ImageTk.PhotoImage(original)

def init_players_image_dict(rnd_im_dict):
    # split dict into four equal chunks
    cnt=1
    for key, values in rnd_im_dict.items():
        if cnt==1:
            sh.player1_im[key]=values
        elif cnt==2:
            sh.player2_im[key]=values
        elif cnt==3:
            sh.player3_im[key]=values
        elif cnt==4:
            sh.player4_im[key]=values
        cnt+=1
        if cnt==5:
            cnt=1

#   ========================================================
#     Support Section
#   ========================================================

def dict_randomization(d):
    ''' How To Iterate Over A Python Dictionary In Random Order? 
        To iterate over the dictionary items in random order get 
        the list of items in a tuple with .items() 
        then shuffle and iterate through this list using 
        the shuffle() and make a new dict with the result'''
    rnd_d={}
    items = list(d.items()) # List of tuples of (key,values)
    random.shuffle(items)
    for key, value in items:
        # print(key, ":", value)
        rnd_d[key]=value
    return rnd_d

def make_mystyle():
    # set TFrame style
    sh.style.map('TFrame',
                background=[('active', '#8B8878'),   # bg2),
                            ('disabled', 'gray76'),
                            ('readonly', 'firebrick2')],
                bordercolor=[('active', '#FFFAFA'),   # fg2),
                            ('disabled', 'gray24'),   # fg1),
                            ('readonly', 'gray50')]   # fg3)],
                )
    sh.style.map('TButton',
                background=[('active', '#8B8878'),
                            ('disabled', 'gray76'),
                            ('readonly', 'firebrick2')],
                foreground=[('active', '#FFFAFA'),
                            ('disabled', 'gray24'),
                            ('readonly', 'gray50')]
                )    

def set_form_color(player):
    # change background color to player color
    sh.style.configure('MyTFrame.TFrame',
                    background=sh.form_color_lst[player],
                    bordercolor='gray24')
    _w1.TFrame1.configure(style='MyTFrame.TFrame')

def set_button_color():
    for inx, button in enumerate(sh.button_lst):
        sh.style.configure(sh.id_lst[inx],
                    background='#8B8878',
                    foreground=sh.form_color_lst[inx]
                        )
        button.configure(style=sh.id_lst[inx])

def display_image(player_dict):
    num=0
    for key, value in player_dict.items():
        set_form_color(sh.player)
        sh.canvas_lst[num].create_image((100, 100), image=value, anchor='center')   # remember x,y is center of image
        num+=1

def validate_input1(*args):
    # start validating this entry
    validate_input(_w1.player1var)
    
def validate_input2(*args):
    # start validating this entry
    validate_input(_w1.player2var)

def validate_input3(*args):
    # start validating this entry
    validate_input(_w1.player3var)

def validate_input4(*args):
    # start validating this entry
    validate_input(_w1.player4var)

def validate_input(player_var):
    # Get the current value of the entry
    input_value = player_var.get()
    # Check if the input is a number
    if input_value.isdigit():
        pass
    else:
        if input_value.endswith(" "):   # space not allowed
            player_var.set('')
        elif input_value.isalpha():     # letter is allowed
            if input_value.istitle():   # first letter must be capitalized
                pass
                #print(f"Input: {input_value} (Word)")
            else:
                player_var.set('')
        else:
            player_var.set('')

def retur_entry1(*args):
    _w1.TEntry1.tk_focusNext().focus_set()
    _w1.TEntry1.config(takefocus=1)

def retur_entry2(*args):
    _w1.TEntry2.tk_focusNext().focus_set()
    _w1.TEntry2.config(takefocus=1)

def retur_entry3(*args):
    _w1.TEntry3.tk_focusNext().focus_set()
    _w1.TEntry3.config(takefocus=1)

def retur_entry4(*args):
    _w1.TBtnGoOn.tk_focusNext().focus_set()
    _w1.TBtnGoOn.config(takefocus=1)

#   ========================================================
#     Program Startup
#   ========================================================

def on_TBtnPlayer1(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer1')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=0
    player_dict=sh.player_lst[sh.player]
    display_image(player_dict)

def on_TBtnPlayer2(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer2')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=1
    player_dict=sh.player_lst[sh.player]
    display_image(player_dict)

def on_TBtnPlayer3(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer3')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=2
    player_dict=sh.player_lst[sh.player]
    display_image(player_dict)

def on_TBtnPlayer4(*args):
    if _debug:
        print('fourplayer_support.on_TBtnPlayer4')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sh.player=3
    player_dict=sh.player_lst[sh.player]
    display_image(player_dict)

def on_TBtnGoOn(*args):
    if _debug:
        print('nameplayers_support.on_TBtnGoOn')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # read player 1    
    sh.player_name[1]=_w1.player1var.get()
    if not len(sh.player_name[1])==0:
        _w1.TBtnPlayer1.configure(text=sh.player_name[1])
    else:
        _w1.TBtnPlayer1.destroy()
    # read player 2
    sh.player_name[2]=_w1.player2var.get()
    if not len(sh.player_name[2])==0:
        _w1.TBtnPlayer2.configure(text=sh.player_name[2])
    else:
        _w1.TBtnPlayer2.destroy()
    # read player 3
    sh.player_name[3]=_w1.player3var.get()
    if not len(sh.player_name[3])==0:
        _w1.TBtnPlayer3.configure(text=sh.player_name[3])
    else:
        _w1.TBtnPlayer3.destroy()
    # read player 4
    sh.player_name[4]=_w1.player4var.get()
    if not len(sh.player_name[4])==0:
        _w1.TBtnPlayer4.configure(text=sh.player_name[4])
    else:
        _w1.TBtnPlayer4.destroy()
    # remove the lid over players button
    _w1.TLblLid.destroy()
    # lift the canvas frame to top
    _w1.TFrame1.lift()
    
def on_TBtnExit(*args):
    if _debug:
        print('nameplayers_support.on_TBtnExit')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    sys.exit()

if __name__ == '__main__':
    nameplayers.start_up()
