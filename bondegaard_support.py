#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# GUI module generated by PAGE version 8.0M
#  in conjunction with Tcl version 8.6
#    Nov 29, 2023 08:13:37 PM CET  platform: Linux

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *
# Support module generated by PAGE version 8.0D
#  in conjunction with Tcl version 8.6
#    Nov 24, 2023 04:40:49 PM CET  platform: Linux
#    Nov 24, 2023 05:12:09 PM CET  platform: Linux
#    Nov 24, 2023 07:25:39 PM CET  platform: Linux
#    Nov 25, 2023 03:11:02 PM CET  platform: Linux
#    Nov 28, 2023 11:35:11 PM CET  platform: Linux
#    Nov 29, 2023 1#! /usr/bin/env python3
#
# GUI module generated by PAGE version 8.0M
#  in conjunction with Tcl version 8.6
#    Nov 29, 2023 08:13:37 PM CET  platform: Linux

import sys
import tkinter as tk
import tkinter.ttk as ttk
from tkinter.constants import *

'''  ToDo:

[x] - lag automatisk share module
[x] - plaser formen i senter sjølv ved bruk av to skjermer, place_toplevel()
[x] - bruk autogui til å gjøre terminalen minimert eller plassert til synlig høyre og ikkje bakom appen
[x] - bruk _show fra tkinter.messagebox modulen til å lage velkomsthilsen
[x] - lag forsinkelse for velkomsthilsen
[x] - lag binding til en tast for å aktivere menyen   <Key-Control_L><Key-Alt_L><Key-m>
[x] - lag programinformasjon i Terminal vinduet
[ ] - legg til slutt informasjon ved avsluttning
[ ] - lag radiobuttons til å velge språk
[ ] - init_user() - developement:
[ ]     - lag og lift en ny frame med Instruksjonstekst, og entry felt for brukar + farge
[ ]     - lag to sett bilder, eit på 660x660 + eit på 200x200
[ ]     - plaser to set bilder og tekst i to dict'er
[ ]     - plaser brukeren si  dict på spilebrettet med tilhøyrende bakgrunnsfarge
[x] - bruk pillow og lag overgangsgif ved trykk på eit memo kort (bakside mot fremside)
[ ] - lag ein dict med bildutvlget i random rekjefølge      
'''
    
import sys
import tkinter as tk
from tkinter import font
import tkinter.ttk as ttk
from tkinter.constants import *

import bondegaard

#-----------------------------------------------------------
# Create an empty module and import while running the script
import os
module_name = "shared"   # empty_module
# Create the empty module file
with open(f"{module_name}.py", "w") as file:
    pass  # This creates an empty file
# Check if the file exists before importing
if os.path.isfile(f"{module_name}.py"):
    import importlib.util
    spec = importlib.util.spec_from_file_location(module_name, f"{module_name}.py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
else:
    print(f"File '{module_name}.py' does not exist. Failed to import the module.")
sh=importlib   # sh is alias shared for short
#-----------------------------------------------------------

# Add some modules from the Python Module Index:
from tkinter.messagebox import _show
from time import time   # time function used to calculate time
import datetime
import random
# Add somme External Modules from pypi.org using pip install ... :
try:
    import pyautogui
    from screeninfo import get_monitors
    from PIL import Image
    import numpy as np
    import imageio
except:
    print('Sorry, you must import this modules: (my ver.)')
    print('PyAutoGUI                 0.9.54')
    print('screeninfo                0.8.1')
    print('Pillow                    10.1.0')
    print('numpy                     1.26.2')
    print('imageio                   2.33.0')

location=bondegaard._location
_debug = True # False to eliminate debug printing from callback functions.

def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = bondegaard.Toplevel1(_top1)
    startup()
    root.mainloop()

def startup():
    _top1.title("Bondegårdslotto")
    place_toplevel()
    menu_state(False)
    _w1.Spinbox1.destroy()
    _w1.Frame3.lower()
    _w1.TBtnExit.configure(text='''Avslutt''')
    root.bind("<Key-Control_L><Key-Alt_L><Key-m>", lambda e: menu_state(e))   # to activate menu
    give_sysem_info()
    init()                     # init variables

#----------------------------------
#    supporting section
#----------------------------------
def place_toplevel():
    ## put the Terminal Form to left edge or Hide it
    if _debug:
        #import pyautoguiimportlib
        pyautogui.hotkey('win','left','down')   #put the Terminal form to left edge
    else:
        #import pyautogui
        pyautogui.hotkey('alt','f10')   # maximize Terminal form first
        pyautogui.moveTo(1840,17, duration=0.2)   # go to minimize button
        pyautogui.doubleClick()   # minimize the Terminal Form
    ## Centers the Form on the screen even when using two screens in join mode
    monitors = get_monitors()   #automate the screen selection
    if len(monitors) == 1:
        screen = 1   #print("There is only one monitor.")
    else:
        screen = 2   #I want to put my app at screen 2 if it is present
    wid=1356   # from gui: top.geometry("1356x738+1956+50")
    hei=738
    center_toplevel(_top1, wid, hei, screen)

def center_toplevel(window, wid, hei, screen_number):
    monitors = get_monitors()
    if 1 <= screen_number <= len(monitors):
        screen = monitors[screen_number - 1]
        window_width = wid
        window_height = hei
        x = screen.x + (screen.width - window_width) // 2
        y = screen.y + (screen.height - window_height) // 2
        window.geometry(f"{window_width}x{window_height}+{x}+{y}")

def menu_state(e):
    if e:
        _w1.menubar.entryconfig("H", state="normal")
    else:
        _w1.menubar.entryconfig("H", state="disabled")

def init():
    global canvas, canvas_right, canvas_left, _img, timer_id, Label, thisPath, imList, userDict 
    canvas_left=_w1.Canvas0    # left canvas
    canvas_right=_w1.Canvas1   # right canvas
    canvas =_w1.Canvas2_8   # test canvas
    canvas.bind("<Button-1>", on_slide)

    thisPath="./assets/lotto_graphics/"
    imList=["4-8thumb.png","init_bakside.png", "test.gif"]
    '''userDict stubb:
       [
        o:active=False/True, 
        # correct findings
        1:im1=False, 2:im2=False, 3:im3=False, 
        4:im4=False, 5:im5=False, 6:im6=False, 
        7:im7=False, 8:im8=False, 9:im9=False,
        #random genererte images 
        10:image1=str, 11:image2=str, 12:image3=str, 
        13:image4=str, 14:image5=str, 15:image6=str, 
        16:image7=str, 17:image8=str, 18:image9=str
        # when is the card solved 
        19:timestamp, 20:timestamp, 21:timestamp,
        22:timestamp, 23:timestamp, 24:timestamp,
        25:timestamp, 26:timestamp, 27:timestamp,] }
    '''
    userDict={'user1':[ False, 
                        False, False, False,
                        False, False, False,
                        False, False, False,
                        "", "", "", 
                        "", "", "", 
                        "", "", "",
                        "", "", "", 
                        "", "", "", 
                        "", "", ""] }
    Label=_w1.TLbl_Time
    Label.configure(text="")
    sh.break_length_card=4000   # 1000 millisec. = 1 sec
    sh.break_length_welcome=1000
    init_imagelist()
    init_images()
    
    init_velcome_screen()   # first screen   # app_exit()
    t= 3000   # 1000 millisec. = 1 sec.
    a_break(sh.break_length_welcome)
    velcome_msg()
    timer_id = root.after(0, on_time_update)   # set time
    init_user_color()
    test_fill_game_board()     # next screen
    init_user()                # second screen   ......    

def init_user_color():
    color_lst=["#008000",   # Emerald green
               "#FDED2E",   # Piss yellow
               "#EA3E2B",   # Tomato
               "#6778B9"]   # Bluish 
    random_lst=random.sample(range(0,4),4)
    # set random color for four players
    sh.player1_color = color_lst[random_lst[0]]
    sh.player2_color = color_lst[random_lst[1]]
    sh.player3_color = color_lst[random_lst[2]]
    sh.player4_color = color_lst[random_lst[3]]

def init_imagelist():
    global image_list
    image_list=["./assets/lotto_graphics/bakside.png",
                "./assets/lotto_graphics/4-1.png", "./assets/lotto_graphics/4-2.png",
                "./assets/lotto_graphics/4-3.png", "./assets/lotto_graphics/4-4.png", 
                "./assets/lotto_graphics/4-5.png", "./assets/lotto_graphics/4-6.png",
                "./assets/lotto_graphics/4-7.png", "./assets/lotto_graphics/4-8.png",
                "./assets/lotto_graphics/4-9.png"] 
    
def init_images():
    global image_list, photo_list
    _img1 = tk.PhotoImage(file=image_list[0])
    _img2 = tk.PhotoImage(file=image_list[1])
    _img3 = tk.PhotoImage(file=image_list[2])
    _img4 = tk.PhotoImage(file=image_list[3])
    _img5 = tk.PhotoImage(file=image_list[4])
    _img6 = tk.PhotoImage(file=image_list[5])
    _img7 = tk.PhotoImage(file=image_list[6])
    _img8 = tk.PhotoImage(file=image_list[7])
    _img9 = tk.PhotoImage(file=image_list[8])
    _img10 = tk.PhotoImage(file=image_list[9])
    photo_list=[_img1, _img2, _img3, _img4, _img5, _img6, _img7, _img8, _img9, _img10]

def canvas_image(num):
    global canvas_right, image_list, photo_list
    _img=photo_list[num]   # image size (660, 660)
    canvas_right.create_image((330, 330), image=_img, anchor='center')   # remember x,y is center of image   

def a_break(t):
    '''take a break'''
    var = tk.IntVar()
    root.after(t, var.set, 1)
    root.wait_variable(var)

    #------------------------------
    #    velcome info
    #------------------------------
def init_velcome_screen():
    global canvas_left, _img
    canvas_image(0)   #set first image on canvas
    #
    _img=tk.PhotoImage(file="./assets/lotto_graphics/bondegaardslotto-fra-damm-egmont.png")   # image size (660, 660)
    canvas_left.create_image((330, 330), image=_img, anchor='center')   # remember x,y is center of image
    '''
    cnt=float(len(image_list))
    _w1.Spinbox1.configure(text="1", 
                           foreground="black",   # set text color in entry field
                           to=cnt,               # set max counter to len image list 
                           justify='center',     # centre the text in entry field 
                           state = 'readonly')   # can't write in entry field
    '''
    #_w1.TLbl_Time.destroy()   # lift() or lower()
    _w1.TLbl_Status.destroy()
    _w1.Frame2.lower()

def velcome_msg():
    global _top1, _w1, _img
    _show(title='Bildelotto', 
          message='''
Spille?          ''', 
          icon='info', 
          _type='ok')   
''' icon=error, info, question, or warning
    _type= abortretryignore, ok, okcancel, retrycancel, yesno, or yesnocancel'''

    #------------------------------
    #    system info
    #------------------------------
def give_sysem_info():
    '''Write information about this Application'''
    # remember to update myFile !!!
    import os
    import platform
    import datetime
    import shared as sh
    sh.decoration = 53
    # get system info
    py_f_name =    os.path.basename(sys.argv[0])
    current_path = os.path.abspath(__file__)
    py_version =   platform.python_version()
    author =       'Halvard Tislavoll'
    licence =      'MIT'
    current_time = datetime.datetime.now()
    sh.current_time_1 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    # read this file and get page version on line 4
    myFile="./bondegaard_support.py"
    signal, all_text=read_text_file_lines(myFile)
    if signal:
        txt_lst=all_text.split('\n')
        sh.page_version=txt_lst[3][-4:]   # list out last of a function line, the "8.0G" from "... PAGE version 8.0G"
        # It is in line 4 but count from 0 it is 3
    else:
        print('Trouble, no _support file is found. Have you give the right name?')
    # print system info
    print()
    print(f'{current_time.year}-{current_time.month}-{current_time.day}')
    print(f'   GUI is constructed using page version {sh.page_version}')
    print(f'   Current path: {current_path}')
    print(f'   Python ver. : {py_version}')
    print(f'   File        : "{py_f_name}" is running')
    print(f'   Start time  : {sh.current_time_1}')
    print(f'   © Copyright : {author}, 2023')
    print(f'   Licence     : {licence}')
    print('-'*sh.decoration, '\n')

    #------------------------------
    #    slide images 
    #------------------------------
def slide_images(image1, image2, offset):
    # Slide image2 over image1 by the specified offset
    width, height, channels = image1.shape
    result = np.zeros_like(image1)

    if offset >= 0:
        result[:, :width-offset] = image1[:, offset:]
        result[:, width-offset:] = image2[:, :offset]
    else:
        result[:, -offset:] = image1[:, :offset]
        result[:, :-offset] = image2[:, -offset:]

    return result

def process_images(image1_path, image2_path, output_gif_path, num_frames=10):
    # Open the images
    image1 = np.array(Image.open(image1_path))
    image2 = np.array(Image.open(image2_path))

    # Ensure both images have the same size
    assert image1.shape == image2.shape, "Images must have the same dimensions."

    # Create a GIF file
    gif_frames = []

    # Generate frames by sliding image2 over image1
    for offset in np.linspace(0, image1.shape[1], num_frames, dtype=int):
        processed_matrix = slide_images(image1, image2, offset)

        # Create an image from the processed data
        gif_frames.append((processed_matrix).astype(np.uint8))

    # Save the frames as a GIF using imageio
    with imageio.get_writer(output_gif_path, mode='I', duration=0.1) as writer:
        for frame in gif_frames:
            writer.append_data(frame)

    #------------------------------
    #    gif animation 
    #------------------------------
def number_of_frames(gif):
    "Prints and returns the number of frames of the gif"
    return gif.n_frames

def update(ind):
    global _top1, canvas, frames
    try:
        frame = frames[ind]
        ind += 1
        canvas.create_image((105, 105), image=frame, anchor='center')
        root.after(45, update, ind)   # duration of image shift
    except:
        pass

def displayfile(filename):
    global _top1, _w1, frames, _image
    file = Image.open(filename)
    frameCnt = number_of_frames(file)
    frames = [tk.PhotoImage( file=filename, format = f'gif -index {i}')
                for i in range(frameCnt)]
    update(0)

    #------------------------------
    #    I/O
    #------------------------------
def read_text_file_lines(filename):
    '''function which read text from file and return the
     file content in a string'''
    try:
        with open(filename, 'r') as f:
            f_text = f.read()
            signal = True   # Done.
            return signal, f_text
    except IOError:
        signal = False   # Something went wrong !!
        return signal, ''

#----------------------------------
#    Program management
#----------------------------------
def set_fremside():
    global _top1, _w1, _img
    _w1.Frame2.lift()
    _img=tk.PhotoImage(file="./assets/lotto_graphics/bondegaardslotto-fra-damm-egmont.png")   # image size (660, 660)
    canvas_left.create_image((330, 330), image=_img, anchor='center')   # remember x,y is center of image

def set_background():   # make a canvas liste
    global _top1, _w1
    global _img61, _img62, _img63, _img64, _img65, _img66, _img67, _img68, _img69
    _img61=None; _img62=None; _img63=None; _img64=None; _img65=None
    _img66=None; _img67=None; _img68=None; _img69=None
    
    _img61=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_1.create_image((105, 105), image=_img61, anchor='center')   # remember x,y is center of image

    _img62=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_2.create_image((105, 105), image=_img62, anchor='center')   # remember x,y is center of image

    _img63=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_3.create_image((105, 105), image=_img63, anchor='center')   # remember x,y is center of image

    _img64=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_4.create_image((105, 105), image=_img64, anchor='center')   # remember x,y is center of image

    _img65=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_5.create_image((105, 105), image=_img65, anchor='center')   # remember x,y is center of image

    _img66=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_6.create_image((105, 105), image=_img66, anchor='center')   # remember x,y is center of image

    _img67=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_7.create_image((105, 105), image=_img67, anchor='center')   # remember x,y is center of image

    _img68=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_8.create_image((105, 105), image=_img68, anchor='center')   # remember x,y is center of image

    _img69=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_9.create_image((105, 105), image=_img69, anchor='center')   # remember x,y is center of image

def test_fill_game_board():
    _w1.Frame2.configure(background=sh.player1_color)
    set_fremside()
    set_background()
    _w1.Canvas1.configure(relief="solid")

def init_user():
    global userDict
    textbox=_w1.Scrolledtext1
    myFont = font.Font(family="Times New Roman", size=20)

    _w1.Frame3.lift()
    _w1.TLblHeading.configure(text="BONDEGÅRDSLOTTO")

    instructions='''
    Alle bildene har bondegårdtema og de vil dukke opp
    på høyre side, eit om gangen.
    På venstre side får hver spiller 9 tilfeldige kort. 
    Spørsmåltegnene er baksiden på kortene. 
    For å sjekke eit kort må kortet velges ved å
    trykke venstre tast på musen på kortet. 
    Da vil bildet på kortet vises i tre sekunder. 
    Dersom kortet er likt det på høyre side vil kortet
    forbli åpent. Kortet er funnet. 
    Valg av kort går på rundgang mellom spillerene. 
    Den brukeren som først har åpnet alle kortene sine 
    har vunnet! Hver spiller får egen farge på brettet.

    Nedenfor må brukerene registrere seg med namn. '''
    
    textbox.configure(font=myFont)

    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # clear text
    textbox.insert('end', instructions)

    #_w1.Frame2.configure(background=sh.player1_color)
    #canvas_image(2)   #set first image on canvas (midlertidig)

    style= ttk.Style()
    style.configure("TEntry", fieldbackground=sh.player1_color)

#----------------------------------
#    Callbacks section
#----------------------------------
def on_time_update():
    global timer_id, Label
    nowstring = f"{datetime.datetime.now():%X}"
    Label.configure(text=nowstring)
    timer_id = root.after(500, on_time_update)

def on_spinbox(*args):
    if _debug:
        print('bondegaard_support.on_spinbox')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which=int(_w1.Spinbox1.get())
    canvas_image(which-1)

def on_slide(*args):
    if _debug:
        print('s_slideImage_support.on_TBtnSlide')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    global canvas, thisPath, imList
    process_images(f"{thisPath}{imList[1]}", f"{thisPath}{imList[0]}", f"{thisPath}{imList[2]}")
    # Display gif
    displayfile(f"{thisPath}{imList[2]}")
    a_break(sh.break_length_card)
    process_images(f"{thisPath}{imList[0]}", f"{thisPath}{imList[1]}", f"{thisPath}{imList[2]}")
    # Display gif again
    displayfile(f"{thisPath}{imList[2]}")

def on_preferences(*args):
    if _debug:
        print('bondegaard_support.on_preferences')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def on_TBtnExit(*args):
    if _debug:
        print('bondegaard_support.on_TBtnExit')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    _show('Avslutt', 'Beklager!\nNå er spillet slutt.')
    sys.exit()

#----------------------------------
#    Program section
#----------------------------------

def on_TBtnRegUser(*args):
    if _debug:
        print('bondegaard_support.on_TBtnRegUser')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

def on_TBtnPlay(*args):
    if _debug:
        print('bondegaard_support.on_TBtnPlay')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

if __name__ == '__main__':
    bondegaard.start_up()





