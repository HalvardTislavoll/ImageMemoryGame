#! /usr/bin/env python3
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 8.0D
#  in conjunction with Tcl version 8.6
#    Nov 24, 2023 04:40:49 PM CET  platform: Linux
#    Nov 24, 2023 05:12:09 PM CET  platform: Linux
#    Nov 24, 2023 07:25center:39 PM CET  platform: Linux
#    Nov 25, 2023 03:11:02 PM CET  platform: Linux
#    Nov 28, 2023 11:35:11 PM CET  platform: Linux
#
# GUI module generated by PAGE version 8.0M
#  in conjunction with Tcl version 8.6
#    Nov 29, 2023 08:13:37 PM CET  platform: Linux

'''  ToDo:

[x] - lag automatisk share module
[x] - plaser formen i senter sjølv ved bruk av to skjermer, place_toplevel()
[x] - bruk autogui til å gjøre terminalen minimert eller plassert til synlig høyre og ikkje bakom appen
[x] - bruk _show fra tkinter.messagebox modulen til å lage velkomsthilsen
[x] - lag forsinkelse for velkomsthilsen
[x] - lag binding til en tast for å aktivere menyen   <Key-Control_L><Key-Alt_L><Key-m>
[x] - lag programinformasjon i Terminal vinduet
[ ] - legg til slutt informasjon ved avsluttning
[ ] - lag radiobuttons til å velge språk
[ ] - init_user() - developement:
[ ]     - lag og lift en ny frame med Instruksjonstekst, og entry felt for brukar + farge
[ ]     - lag to sett bilder, eit på 660x660 + eit på 200x200
[ ]     - plaser to set bilder og tekst i to dict'er
[ ]     - plaser brukeren si  dict på spilebrettet med tilhøyrende bakgrunnsfarge
[x] - bruk pillow og lag overgangsgif ved trykk på eit memo kort (bakside mot fremside)
[ ] - lag ein dict med bildutvlget i random rekjefølge      
'''

# =============================================================================
#
# Moduleimport section
# ~~~~~~~~~~~~~~~~~~~~~~     
import sys
import tkinter as tk
from tkinter import font
import tkinter.ttk as ttk
from tkinter.constants import *

import bondegaard

#-----------------------------------------------------------
# Create an empty module and import while running the script
import os
module_name = "shared"   # empty_module
# Create the empty module file
with open(f"{module_name}.py", "w") as file:
    pass  # This creates an empty file
# Check if the file exists before importing
if os.path.isfile(f"{module_name}.py"):
    import importlib.util
    spec = importlib.util.spec_from_file_location(module_name, f"{module_name}.py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
else:
    print(f"File '{module_name}.py' does not exist. Failed to import the module.")
sh=importlib   # sh is alias shared for short
#-----------------------------------------------------------

# Add some modules internal from Python:
from tkinter.messagebox import _show
from time import time   # time function used to calculate time
import platform
import datetime
import random
# Add somme External Modules from pypi.org Python Module Index using pip install ... :
try:
    import pyautogui
    from screeninfo import get_monitors
    from PIL import Image
    import numpy as np
    import imageio
    from tksheet import Sheet   # This is the external class that implements the sheet (data grid) widget.
except:
    print('Sorry, you must install this modules: (my ver.)')
    print('PyAutoGUI                 0.9.54')
    print('screeninfo                0.8.1')
    print('Pillow                    10.1.0')
    print('numpy                     1.26.2')
    print('imageio                   2.33.0')
    print('tksheet                   6.3.0')

location=bondegaard._location
_debug = True # False to eliminate debug printing from callback functions.

# =============================================================================
#
# Initial section
# ~~~~~~~~~~~~~~~~~
def main(*args):
    '''Main entry point for the application.'''
    global root
    root = tk.Tk()
    root.protocol( 'WM_DELETE_WINDOW' , root.destroy)
    # Creates a toplevel widget.
    global _top1, _w1
    _top1 = root
    _w1 = bondegaard.Toplevel1(_top1)
    startup()   # This is my first code in this script
    root.mainloop()

def startup():
    _top1.title("Bondegårdslotto")
    give_sysem_info()   
    place_toplevel()
    menu_state(False)
    root.bind("<Key-Control_L><Key-Alt_L><Key-m>", lambda e: menu_state(e))   # to activate menu
    _w1.Spinbox1.destroy()
    _w1.Frame3.lower()
    _w1.Frame4.lower()
    _w1.TBtnExit.configure(text="Avslutt")
    _w1.TLblHeading.configure(text="S P I L L E R E G L E R")
    init()   # init variables

# =============================================================================
#
# Supporting section
# ~~~~~~~~~~~~~~~~~~~
def place_toplevel():
    ## put the Terminal Form to left edge or Hide it
    if _debug:
        #import pyautoguiimportlib
        pyautogui.hotkey('win','left','down')   #put the Terminal form to left edge
    else:
        #import pyautogui
        pyautogui.hotkey('alt','f10')   # maximize Terminal form first
        pyautogui.moveTo(1840,17, duration=0.2)   # go to minimize button
        pyautogui.doubleClick()   # minimize the Terminal Form
    ## Centers the Form on the screen even when using two screens in join mode
    monitors = get_monitors()   #automate the screen selection
    if len(monitors) == 1:
        screen = 1   #print("There is only one monitor.")
    else:
        screen = 2   #I want to put my app at screen 2 if it is present
    wid=1356   # from gui: top.geometry("1356x738+1956+50")
    hei=738
    center_toplevel(_top1, wid, hei, screen)

def center_toplevel(window, wid, hei, screen_number):
    '''plaser toplevel form sentrert på skjermen. 
       Ved bruk av to skjermer og join metode vil 
       formen sentreres på skjerm to'''
    monitors = get_monitors()
    if 1 <= screen_number <= len(monitors):
        screen = monitors[screen_number - 1]
        window_width = wid
        window_height = hei
        x = screen.x + (screen.width - window_width) // 2
        y = screen.y + (screen.height - window_height) // 2
        window.geometry(f"{window_width}x{window_height}+{x}+{y}")

def menu_state(e):
    '''gjør menyen tilgjengelig ved å endre status'''
    if e:
        _w1.menubar.entryconfig("H", state="normal")
    else:
        _w1.menubar.entryconfig("H", state="disabled")

def init():
    # set names on canvases
    sh.canvas_left=_w1.Canvas0    # left canvas
    sh.canvas_right=_w1.Canvas1   # right canvas
    sh.canvas =_w1.Canvas2_8   # test canvas
    # bind an event on canvas
    sh.canvas.bind("<Button-1>", on_slide)
    # set path to images
    sh.thisPath="./assets/lotto_graphics/"
    
    sh.imList=["4-8thumb.png","init_bakside.png", "test.gif"]
    '''userDict stubb:
       [
        o:active=False/True, 
        # correct findings
        1:im1=False, 2:im2=False, 3:im3=False, 
        4:im4=False, 5:im5=False, 6:im6=False, 
        7:im7=False, 8:im8=False, 9:im9=False,
        #random genererte images 
        10:image1=str, 11:image2=str, 12:image3=str, 
        13:image4=str, 14:image5=str, 15:image6=str, 
        16:image7=str, 17:image8=str, 18:image9=str
        # when is the card solved 
        19:timestamp, 20:timestamp, 21:timestamp,
        22:timestamp, 23:timestamp, 24:timestamp,
        25:timestamp, 26:timestamp, 27:timestamp,] }
    '''
    # make a user dict with status of play progress
    sh.userDict={'user1':[ False, 
                        False, False, False,
                        False, False, False,
                        False, False, False,
                        "", "", "", 
                        "", "", "", 
                        "", "", "",
                        "", "", "", 
                        "", "", "", 
                        "", "", ""] }
    # set Time label
    sh.Label=_w1.TLbl_Time
    sh.Label.configure(text="")
    timer_id = root.after(0, on_time_update)   # set time
    # set break length
    sh.break_length_card=4000   # 1000 millisec. = 1 sec
    sh.break_length_welcome=1000
    sh.break_length_contine=1000
    # make a image list and init images
    init_imagelist()
    init_images()
    # make four random color for users
    init_user_color()
    #------------------------------
    #    welcom screen 
    #------------------------------
    init_velcome_screen()   # first screen   # app_exit()
    a_break(sh.break_length_welcome)
    velcome_msg()
    #------------------------------
    #    instruction screen 
    #------------------------------
    init_instruction_screen()
    a_break(sh.break_length_contine)   # give the screen some time before asking for continuing
    continue_msg()   # wait for userinput
    #------------------------------
    #    registration screen 
    #------------------------------
    init_registration_screen()   # third screen   ......
    
    #test_fill_game_board()     # next screen


def init_user_color():
    color_lst=["#008000",   # Emerald green
               "#FDED2E",   # Piss yellow
               "#EA3E2B",   # Tomato
               "#6778B9"]   # Bluish 
    random_lst=random.sample(range(0,4),4)
    # set random color for four players
    sh.player1_color = color_lst[random_lst[0]]
    sh.player2_color = color_lst[random_lst[1]]
    sh.player3_color = color_lst[random_lst[2]]
    sh.player4_color = color_lst[random_lst[3]]

def init_imagelist():
    sh.image_list=["./assets/lotto_graphics/owl_right_biledlotto.png",
                "./assets/lotto_graphics/4-1.png", "./assets/lotto_graphics/4-2.png",
                "./assets/lotto_graphics/4-3.png", "./assets/lotto_graphics/4-4.png", 
                "./assets/lotto_graphics/4-5.png", "./assets/lotto_graphics/4-6.png",
                "./assets/lotto_graphics/4-7.png", "./assets/lotto_graphics/4-8.png",
                "./assets/lotto_graphics/4-9.png"] 
    
def init_images():
    _img1 = tk.PhotoImage(file=sh.image_list[0])
    _img2 = tk.PhotoImage(file=sh.image_list[1])
    _img3 = tk.PhotoImage(file=sh.image_list[2])
    _img4 = tk.PhotoImage(file=sh.image_list[3])
    _img5 = tk.PhotoImage(file=sh.image_list[4])
    _img6 = tk.PhotoImage(file=sh.image_list[5])
    _img7 = tk.PhotoImage(file=sh.image_list[6])
    _img8 = tk.PhotoImage(file=sh.image_list[7])
    _img9 = tk.PhotoImage(file=sh.image_list[8])
    _img10 = tk.PhotoImage(file=sh.image_list[9])
    sh.photo_list=[_img1, _img2, _img3, _img4, _img5, _img6, _img7, _img8, _img9, _img10]

def canvas_image(num):
    _img=sh.photo_list[num]   # image size (660, 660)
    sh.canvas_right.create_image((330, 330), image=_img, anchor='center')   # remember x,y is center of image   

def a_break(t):
    '''take a break'''
    var = tk.IntVar()
    root.after(t, var.set, 1)
    root.wait_variable(var)

    #------------------------------
    #    velcome info
    #------------------------------
def init_velcome_screen():
    canvas_image(0)   #set first image on canvas
    sh.bondegaardslotto=tk.PhotoImage(file="./assets/lotto_graphics/bondegaardslotto-fra-damm-egmont.png")   # image size (660, 660)
    sh.canvas_left.create_image((330, 330), image=sh.bondegaardslotto, anchor='center')   # remember x,y is center of image
    '''
    cnt=float(len(image_list))
    _w1.Spinbox1.configure(text="1", 
                           foreground="black",   # set text color in entry field
                           to=cnt,               # set max counter to len image list 
                           justify='center',     # centre the text in entry field 
                           state = 'readonly')   # can't write in entry field
    '''
    #_w1.TLbl_Time.destroy()   # lift() or lower()
    _w1.TLbl_Status.destroy()
    _w1.Frame2.lower()

    #------------------------------
    #    instruction info
    #------------------------------
def init_instruction_screen():
    sh.canvas_left.delete("all")
    canvas_image(0)   #set first image on canvas
    sh.owl_left=tk.PhotoImage(file= "./assets/lotto_graphics/owl_left.png")   # image size (660, 660)
    sh.canvas_left.create_image((330, 330), image=sh.owl_left, anchor='center')   # remember x,y is center of image   
    _w1.Frame0.lift()
    instruction()   # second screen   ......    

def init_registration_screen():
    
    # lift canvas_right frame
    # display owl_right
    _w1.Frame0.lift()
    
    canvas_image(0)   #set first image on canvas
    sh.owl_right=tk.PhotoImage(file="./assets/lotto_graphics/owl_right_biledlotto.png")   # image size (660, 660)
    sh.canvas_right.create_image((330, 330), image=sh.owl_right, anchor='center')   # remember x,y is center of image    

    _w1.Frame4.lift()
    
    style= ttk.Style()
    # set style to Custom TEntry
    style.configure('TEntry1.TEntry', fieldbackground=sh.player1_color)
    style.configure('TEntry2.TEntry', fieldbackground=sh.player2_color)
    style.configure('TEntry3.TEntry', fieldbackground=sh.player3_color)
    style.configure('TEntry4.TEntry', fieldbackground=sh.player4_color)
    # assosiate the entrys with custom entry
    _w1.TEntry1.configure(style='TEntry1.TEntry')
    _w1.TEntry2.configure(style='TEntry2.TEntry')
    _w1.TEntry3.configure(style='TEntry3.TEntry')
    _w1.TEntry4.configure(style='TEntry4.TEntry')
  
    #_w1.Frame2.configure(background=sh.player1_color)
    #canvas_image(2)   #set first image on canvas (midlertidig)

def velcome_msg():
    global _top1, _w1, _img
    _show(title='Bildelotto', 
          message='''
Spille?          ''', 
          icon='question', 
          _type='ok')   
''' icon=error, info, question, or warning
    _type= abortretryignore, ok, okcancel, retrycancel, yesno, or yesnocancel'''

def continue_msg():
    global _top1, _w1, _img
    _show(title='fortsette', 
          message="   ", 
          icon='question', 
          _type='ok')

    #------------------------------
    #    system info
    #------------------------------
def give_sysem_info():
    '''Write information about this Application'''
    # remember to update myFile !!!
    sh.decoration = 53
    # get system info
    py_f_name =    os.path.basename(sys.argv[0])
    current_path = os.path.abspath(__file__)
    py_version =   platform.python_version()
    author =       'Halvard Tislavoll'
    licence =      'MIT'
    current_time = datetime.datetime.now()
    sh.current_time_1 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    # read this file and get page version on line 4
    myFile="./bondegaard_support.py"
    signal, all_text=read_text_file_lines(myFile)
    if signal:
        txt_lst=all_text.split('\n')
        sh.page_version=txt_lst[3][-4:]   # list out last of a function line, the "8.0G" from "... PAGE version 8.0G"
        # It is in line 4 but count from 0 it is 3
    else:
        print('Trouble, no _support file is found. Have you give the right name?')
    # print system info
    print()
    print(f'{current_time.year}-{current_time.month}-{current_time.day}')
    print(f'   GUI is constructed using page version {sh.page_version}')
    print(f'   Current path: {current_path}')
    print(f'   Python ver. : {py_version}')
    print(f'   File        : "{py_f_name}" is running')
    print(f'   Start time  : {sh.current_time_1}')
    print(f'   © Copyright : {author}, 2023')
    print(f'   Licence     : {licence}')
    print('-'*sh.decoration, '\n')

    #------------------------------
    #    slide images 
    #------------------------------
def slide_images(image1, image2, offset):
    # Slide image2 over image1 by the specified offset
    width, height, channels = image1.shape
    result = np.zeros_like(image1)

    if offset >= 0:
        result[:, :width-offset] = image1[:, offset:]
        result[:, width-offset:] = image2[:, :offset]
    else:
        result[:, -offset:] = image1[:, :offset]
        result[:, :-offset] = image2[:, -offset:]

    return result

def process_images(image1_path, image2_path, output_gif_path, num_frames=10):
    # Open the images
    image1 = np.array(Image.open(image1_path))
    image2 = np.array(Image.open(image2_path))

    # Ensure both images have the same size
    assert image1.shape == image2.shape, "Images must have the same dimensions."

    # Create a GIF file
    gif_frames = []

    # Generate frames by sliding image2 over image1
    for offset in np.linspace(0, image1.shape[1], num_frames, dtype=int):
        processed_matrix = slide_images(image1, image2, offset)

        # Create an image from the processed data
        gif_frames.append((processed_matrix).astype(np.uint8))

    # Save the frames as a GIF using imageio
    with imageio.get_writer(output_gif_path, mode='I', duration=0.1) as writer:
        for frame in gif_frames:
            writer.append_data(frame)

    #------------------------------
    #    gif animation 
    #------------------------------
def number_of_frames(gif):
    "Prints and returns the number of frames of the gif"
    return gif.n_frames

def update(ind):
    global _top1, frames
    try:
        frame = frames[ind]
        ind += 1
        sh.canvas.create_image((105, 105), image=frame, anchor='center')
        root.after(45, update, ind)   # duration of image shift
    except:
        pass

def displayfile(filename):
    global _top1, _w1, frames, _image
    file = Image.open(filename)
    frameCnt = number_of_frames(file)
    frames = [tk.PhotoImage( file=filename, format = f'gif -index {i}')
                for i in range(frameCnt)]
    update(0)

    #------------------------------
    #    I/O
    #------------------------------
def read_text_file_lines(filename):
    '''function which read text from file and return the
     file content in a string'''
    try:
        with open(filename, 'r') as f:
            f_text = f.read()
            signal = True   # Done.
            return signal, f_text
    except IOError:
        signal = False   # Something went wrong !!
        return signal, ''

def remove_tmp_file():
    '''removes share.py file created by the program while running'''
    filename = f"{module_name}.py"
    try:
        import os
        os.remove(filename)   # remove files
        print(f'   Temperary file is removed ')
    except:
        print(f'   Can not remove file: {filename}, sorry!')

#----------------------------------
#
#    Program management
#
#----------------------------------

def set_fremside():
    global _top1, _w1, _img
    _w1.Frame2.lift()
    _img=tk.PhotoImage(file="./assets/lotto_graphics/bondegaardslotto-fra-damm-egmont.png")   # image size (660, 660)
    sh.canvas_left.create_image((330, 330), image=_img, anchor='center')   # remember x,y is center of image

def set_background():   # make a canvas liste
    global _top1, _w1
    global _img61, _img62, _img63, _img64, _img65, _img66, _img67, _img68, _img69
    _img61=None; _img62=None; _img63=None; _img64=None; _img65=None
    _img66=None; _img67=None; _img68=None; _img69=None
    
    _img61=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_1.create_image((105, 105), image=_img61, anchor='center')   # remember x,y is center of image

    _img62=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_2.create_image((105, 105), image=_img62, anchor='center')   # remember x,y is center of image

    _img63=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_3.create_image((105, 105), image=_img63, anchor='center')   # remember x,y is center of image

    _img64=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_4.create_image((105, 105), image=_img64, anchor='center')   # remember x,y is center of image

    _img65=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_5.create_image((105, 105), image=_img65, anchor='center')   # remember x,y is center of image

    _img66=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_6.create_image((105, 105), image=_img66, anchor='center')   # remember x,y is center of image

    _img67=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_7.create_image((105, 105), image=_img67, anchor='center')   # remember x,y is center of image

    _img68=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_8.create_image((105, 105), image=_img68, anchor='center')   # remember x,y is center of image

    _img69=tk.PhotoImage(file="./assets/lotto_graphics/init_bakside.png")   # image size (200x200)
    _w1.Canvas2_9.create_image((105, 105), image=_img69, anchor='center')   # remember x,y is center of image

def test_fill_game_board():
    _w1.Frame2.configure(background=sh.player1_color)
    set_fremside()
    set_background()
    _w1.Canvas1.configure(relief="solid")

def instruction():
    textbox=_w1.Scrolledtext1
    myFont = font.Font(family="Times New Roman", size=20)
    _w1.Frame3.lift()
    instructions='''    Bondegårdslotto er eit bildelotto. Det betyr lek med
    bilder. Alle bildene har bondegårdstema. 
    Det er to og to like bilder og spillerene får hver sitt
    brett med ni tilfeldige bilder og hver sin bakgrunns-
    farge. Bildene på spillebrettet ligger med baksiden opp. 
    Spelebrettet er plassert på venstre side. På høgre side 
    er det ein bunke bilder. Disse er store i forhold til 
    bildene på spillebrettet. Det øverste vises, men bunken
    har like mange bilder som alle bildene på brettene.
    Bildene i bunken er ordet i tilfeldig rekkefølge. 
    Spillerene får snu eit kort om gangen. Bildekortene på 
    brettet til spilleren kan vendes ved eit musetrykk.
    Dersom kortet som blir snudd er likt med det store 
    kortet på høgre side vil kortet forbli liggende åpent.
    Elles vil kortet snu seg igjen etter tre sekunder. 
    Den spilleren som først har alle kortene sine åpne,
    vinner spillet. Lykke til'''
    textbox.configure(font=myFont)
    textbox.configure(wrap="word")
    textbox.delete(1.0, "end")   # clear text
    textbox.insert('end', instructions)

    #------------------------------
    #    cleanup info
    #------------------------------
def cleanUp():
    '''Calculates the Time Spent and Notifies that the App is Finished.
       Can Optionally Remove Tempered Files.'''
    # import datetime
    print('='*sh.decoration, '\n')
    # give finish time
    current_time = datetime.datetime.now()
    current_time_2 = f'{current_time.hour:02}:{current_time.minute:02}:{current_time.second}'
    h1,m1,s1 = sh.current_time_1.split(':')
    h2,m2,s2 = current_time_2.split(':')
    tot_h=int(h2)-int(h1)
    tot_m=int(m2)-int(m1)
    tot_s=int(s2)-int(s1)
    if tot_s < 0:
        tot_m-=1
        tot_s=60+tot_s
    if tot_m < 0:
        tot_h-=1
        tot_m=60+tot_m
    tot_time=f'{tot_h:02}:{tot_m:02}:{tot_s:02}'
    print(f'   finish time : {current_time_2}')
    print('   time used   :', tot_time )
    remove_tmp_file()
    _show('Avslutt', 'Beklager!\nNå er spillet slutt.')
    print('Done.')

# =============================================================================
#
# Callback section
# ~~~~~~~~~~~~~~~~~

    #------------------------------
    #    Time management
    #------------------------------
def on_time_update():
    global timer_id
    nowstring = f"{datetime.datetime.now():%X}"
    sh.Label.configure(text=nowstring)
    timer_id = root.after(500, on_time_update)

    #------------------------------
    #    Images view, one by one
    #------------------------------
def on_spinbox(*args):
    if _debug:
        print('bondegaard_support.on_spinbox')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    which=int(_w1.Spinbox1.get())
    canvas_image(which-1)

    #------------------------------
    #    Image turn for a while
    #------------------------------
def on_slide(*args):
    if _debug:
        print('s_slideImage_support.on_TBtnSlide')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    process_images(f"{sh.thisPath}{sh.imList[1]}", f"{sh.thisPath}{sh.imList[0]}", f"{sh.thisPath}{sh.imList[2]}")
    # Display gif
    displayfile(f"{sh.thisPath}{sh.imList[2]}")
    a_break(sh.break_length_card)
    process_images(f"{sh.thisPath}{sh.imList[0]}", f"{sh.thisPath}{sh.imList[1]}", f"{sh.thisPath}{sh.imList[2]}")
    # Display gif again
    displayfile(f"{sh.thisPath}{sh.imList[2]}")

    #------------------------------
    #    Program setting by user
    #------------------------------
def on_preferences(*args):
    if _debug:
        print('bondegaard_support.on_preferences')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

    #------------------------------
    #    Start the game
    #------------------------------
def on_TBtnPlay(*args):
    if _debug:
        print('bondegaard_support.on_TBtnPlay')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()

    #------------------------------
    #    Program Quit
    #------------------------------
def on_TBtnExit(*args):
    if _debug:
        print('bondegaard_support.on_TBtnExit')
        for arg in args:
            print ('    another arg:', arg)
        sys.stdout.flush()
    # Here starts my code
    cleanUp()
    sys.exit()

#----------------------------------
#    Program Start
#----------------------------------

if __name__ == '__main__':
    bondegaard.start_up()





